import {
  getValidAccessToken,
  json,
  moodTargets,
  readJsonBody,
  spotifyRequest,
} from "../_lib/spotify.js";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return json(res, 405, { error: "Method not allowed" });
  }

  let mood;
  try {
    const body = await readJsonBody(req);
    mood = String(body.mood || "").toLowerCase();
  } catch {
    return json(res, 400, { error: "Invalid JSON payload" });
  }

  const settings = moodTargets[mood];
  if (!settings) {
    return json(res, 400, { error: "Unsupported mood" });
  }

  const accessToken = await getValidAccessToken(req, res);
  if (!accessToken) {
    return json(res, 401, { error: "Not authenticated with Spotify" });
  }

  try {
    const pickUris = (tracks, currentMarket) =>
      Array.from(
        new Set(
          (tracks || [])
            .filter((track) => track && typeof track.uri === "string")
            .filter((track) => track.uri.startsWith("spotify:track:"))
            .filter((track) => !track.is_local)
            .filter((track) => track.is_playable !== false)
            .filter((track) => {
              if (!Array.isArray(track.available_markets) || !track.available_markets.length) {
                return true;
              }
              return track.available_markets.includes(currentMarket);
            })
            .map((track) => track.uri)
        )
      ).slice(0, 20);

    const me = await spotifyRequest("GET", "/me", accessToken);
    const market = me.country || "US";
    const seedGenres = String(settings.seed_genres || "")
      .split(",")
      .map((g) => g.trim())
      .filter(Boolean);
    let uris = [];

    // Try recommendations, but don't fail the full request if Spotify rejects this endpoint/params.
    try {
      const recs = await spotifyRequest("GET", "/recommendations", accessToken, {
        query: {
          ...settings,
          limit: 20,
          market,
        },
      });
      uris = pickUris(recs.tracks, market);
    } catch {
      uris = [];
    }

    if (!uris.length) {
      try {
        const recs = await spotifyRequest("GET", "/recommendations", accessToken, {
          query: {
            seed_genres: settings.seed_genres,
            limit: 20,
            market,
          },
        });
        uris = pickUris(recs.tracks, market);
      } catch {
        uris = [];
      }
    }

    if (!uris.length && seedGenres.length) {
      const searchResults = [];
      for (const genre of seedGenres.slice(0, 3)) {
        try {
          const search = await spotifyRequest("GET", "/search", accessToken, {
            query: {
              q: `genre:${genre}`,
              type: "track",
              limit: 10,
              market,
            },
          });
          searchResults.push(...(search.tracks?.items || []));
        } catch {
          // Keep trying other seeds.
        }
      }

      uris = pickUris(searchResults, market);
    }

    if (!uris.length) {
      return json(res, 404, {
        error: "No recommended tracks for this mood",
        details: "Try a different mood or reconnect Spotify.",
      });
    }

    const now = new Date().toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });

    const playlist = await spotifyRequest("POST", "/me/playlists", accessToken, {
      body: {
        name: `${mood[0].toUpperCase() + mood.slice(1)} Mood Mix (${now})`,
        description: `Auto-generated by Moodify for a ${mood} vibe`,
        public: false,
      },
    });

    let tracksAdded = 0;
    let addFailure = null;
    let addMethod = null;
    try {
      await spotifyRequest("POST", `/playlists/${playlist.id}/tracks`, accessToken, {
        body: { uris },
      });
      tracksAdded = uris.length;
      addMethod = "POST body";
    } catch (addErr) {
      addFailure = addErr;
      try {
        await spotifyRequest("POST", `/playlists/${playlist.id}/tracks`, accessToken, {
          query: { uris: uris.join(",") },
        });
        tracksAdded = uris.length;
        addMethod = "POST query";
      } catch (queryErr) {
        addFailure = queryErr;
      }
    }

    if (!tracksAdded) {
      try {
        await spotifyRequest("PUT", `/playlists/${playlist.id}/tracks`, accessToken, {
          body: { uris },
        });
        tracksAdded = uris.length;
        addMethod = "PUT body";
      } catch (putErr) {
        addFailure = putErr;
      }
    }

    if (!tracksAdded) {
      // Fallback: attempt per-track insert so one invalid/restricted track won't fail the whole request.
      for (const uri of uris) {
        try {
          await spotifyRequest("POST", `/playlists/${playlist.id}/tracks`, accessToken, {
            query: { uris: uri },
          });
          tracksAdded += 1;
          addMethod = "POST query per-track";
        } catch {
          // Skip failing tracks.
        }
      }
    }

    if (!tracksAdded) {
      return json(res, 200, {
        ok: false,
        partial: true,
        error: "Playlist created but failed to add tracks",
        details: addFailure?.message || "Unknown track insert error",
        spotifyStatus: addFailure?.status || null,
        spotifyError: addFailure?.details || null,
        spotifyAuth: addFailure?.spotifyAuth || null,
        spotifyRequestId: addFailure?.spotifyRequestId || null,
        addMethod,
        failedAt: "POST /playlists/{playlist_id}/tracks",
        playlist: {
          id: playlist.id,
          name: playlist.name,
          url: playlist.external_urls?.spotify,
        },
        tracksAdded: 0,
      });
    }

    return json(res, 200, {
      ok: true,
      partial: tracksAdded < uris.length,
      playlist: {
        id: playlist.id,
        name: playlist.name,
        url: playlist.external_urls?.spotify,
      },
      tracksAdded,
      addMethod,
    });
  } catch (error) {
    const statusCode = Number(error?.status) || 500;
    const details =
      error?.details?.error?.message || error?.details?.error || error?.details || error?.message;

    return json(res, statusCode, {
      error: "Failed to create playlist",
      details,
    });
  }
}
