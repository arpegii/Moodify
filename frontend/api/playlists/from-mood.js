import {
  getValidAccessToken,
  json,
  moodTargets,
  readJsonBody,
  spotifyRequest,
} from "../_lib/spotify.js";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return json(res, 405, { error: "Method not allowed" });
  }

  let mood;
  try {
    const body = await readJsonBody(req);
    mood = String(body.mood || "").toLowerCase();
  } catch {
    return json(res, 400, { error: "Invalid JSON payload" });
  }

  const settings = moodTargets[mood];
  if (!settings) {
    return json(res, 400, { error: "Unsupported mood" });
  }

  const accessToken = await getValidAccessToken(req, res);
  if (!accessToken) {
    return json(res, 401, { error: "Not authenticated with Spotify" });
  }

  try {
    const me = await spotifyRequest("GET", "/me", accessToken);
    const market = me.country || "US";
    const seedGenres = String(settings.seed_genres || "")
      .split(",")
      .map((g) => g.trim())
      .filter(Boolean);
    let uris = [];

    // Try recommendations, but don't fail the full request if Spotify rejects this endpoint/params.
    try {
      const recs = await spotifyRequest("GET", "/recommendations", accessToken, {
        query: {
          ...settings,
          limit: 20,
          market,
        },
      });
      uris = (recs.tracks || []).map((track) => track.uri).filter(Boolean);
    } catch {
      uris = [];
    }

    if (!uris.length) {
      try {
        const recs = await spotifyRequest("GET", "/recommendations", accessToken, {
          query: {
            seed_genres: settings.seed_genres,
            limit: 20,
            market,
          },
        });
        uris = (recs.tracks || []).map((track) => track.uri).filter(Boolean);
      } catch {
        uris = [];
      }
    }

    if (!uris.length && seedGenres.length) {
      const searchResults = [];
      for (const genre of seedGenres.slice(0, 3)) {
        try {
          const search = await spotifyRequest("GET", "/search", accessToken, {
            query: {
              q: `genre:${genre}`,
              type: "track",
              limit: 10,
              market,
            },
          });
          searchResults.push(...(search.tracks?.items || []));
        } catch {
          // Keep trying other seeds.
        }
      }

      uris = Array.from(new Set(searchResults.map((track) => track.uri).filter(Boolean))).slice(
        0,
        20
      );
    }

    if (!uris.length) {
      return json(res, 404, {
        error: "No recommended tracks for this mood",
        details: "Try a different mood or reconnect Spotify.",
      });
    }

    const now = new Date().toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });

    const playlist = await spotifyRequest("POST", "/me/playlists", accessToken, {
      body: {
        name: `${mood[0].toUpperCase() + mood.slice(1)} Mood Mix (${now})`,
        description: `Auto-generated by Moodify for a ${mood} vibe`,
        public: false,
      },
    });

    try {
      await spotifyRequest("POST", `/playlists/${playlist.id}/tracks`, accessToken, {
        body: { uris },
      });
    } catch (addErr) {
      return json(res, 200, {
        ok: false,
        partial: true,
        error: "Playlist created but failed to add tracks",
        details:
          addErr?.details?.error?.message ||
          addErr?.details?.error ||
          addErr?.message ||
          "Unknown track insert error",
        playlist: {
          id: playlist.id,
          name: playlist.name,
          url: playlist.external_urls?.spotify,
        },
        tracksAdded: 0,
      });
    }

    return json(res, 200, {
      ok: true,
      playlist: {
        id: playlist.id,
        name: playlist.name,
        url: playlist.external_urls?.spotify,
      },
      tracksAdded: uris.length,
    });
  } catch (error) {
    const statusCode = Number(error?.status) || 500;
    const details =
      error?.details?.error?.message || error?.details?.error || error?.details || error?.message;

    return json(res, statusCode, {
      error: "Failed to create playlist",
      details,
    });
  }
}
